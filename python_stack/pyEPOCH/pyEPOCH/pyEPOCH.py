#!/usr/bin/env python
# coding=UTF-8

from __future__ import print_function
#from __future__ import subprocess32
import sys as _sys
import math as _math
import numpy as _np
import datetime as _dt
import collections as _collections
import copy as _copy
import os as _os
import re as _re
import shutil as _shutil
import subprocess32 as _sp
import multiprocessing as _mp
import time as _time
#import Queue as _Queue
import queue as _Queue
import threading as _threading
import daemon as _daemon
from scipy import constants as _const

import pbsUtils as pbs
from .deckspec import deckspec
from .inputBlock import inputBlock
from .version import __version__

class inputDeck:
	''' A class for managing the creation of a verified input deck

	Internally stores the deck as a dictionary. This dictionary associates
	block names (e.g. 'control' or 'boundaries') with a list of block objects.

	Each block that is added is tested for validity and rejected if not valid.

	This is purposefully designed with no unique block identifier, blocks may
	only be identified by their type and the parameters stored within.
	'''

	# Shared variable defining possible input decks
	# Contains a dictionary of dictionaries.
	#  - Outer dictionary selects blocks, indexed by block name
	#  - Inner dictionary defines individual blocks, see example
	blockDefinitions = deckspec.blockDefinitions

	def __init__(self,dims):
		self._deck = { bName: [] for bName in inputDeck._getBlockNames() }
		if(dims >= 1 and dims <= 3):
			self.dims = dims
		else:
			raise ValueError("dims must be between 1 and 3")

	def __str__(self):
		newLineChar = '\n'
		indentChar = '    '

		messages = inputDeck.whyInvalid(self)
		valid = not messages
		if not valid: messages = [ '# - '+i for i in messages ]

		if(valid): validityStatus = ["# Input deck has been checked and no problems were identified"]
		else: validityStatus = ["# WARNING: Input deck is NOT valid for the following reasons:"] + messages

		header = [ "# EPOCH"+str(self.dims)+"D input deck generated by pyEPOCH version "+__version__,
		           "# Generated at: "+_dt.datetime.utcnow().isoformat(),'# '] + validityStatus + [""]

		body = []

		# Blocks can't go in arbitrary order
		blockOrder = ['control','boundaries','species',
		              'laser','fields','dist_fn','collisions',
					  'probe','subset','qed','window',
		              'output_global','output']

		for bName in blockOrder:
			if bName in self:
				for block in self[bName]:
					body += str(block).splitlines()
					body.append('')

		footer = []

		string = newLineChar.join(header + body + footer)

		return string

	def __eq__(self,other):
		# We're only interested in whether the blocks match up
		# Any other object metadata can be safely discarded
		s = self._getAllBlocks()
		o = other._getAllBlocks()

		if len(s) != len(o): return False
		else:
			return all([ s[i] == o[i] for i in range(len(s)) ])

	def __neq__(self,other):
		return not self.__eq__(other)

	def __getitem__(self,key):
		''' Alias of getBlocksOfType

		Returns a copy of blocks of a particular type
		'''
		return self.getBlocksOfType(key)

	def __contains__(self,other):
		''' Checks whether a given block or block type in the deck '''
		if isinstance(other,inputBlock):
			# Check block name is valid
			inputDeck._isValidBlockName(other.blockName,noerror=False)

			# Go through all blocks of that type and check they match
			matchingBlocks = [ other == block for block in self._getBlocksOfType(other.blockName) ]

			return any(matchingBlocks)
		elif isinstance(other,str):
			return other in self._deck.keys()
		else:
			raise TypeError('\'In <inputDeck>\' requires block or string as left operand, not {type}'.format(type=type(other)))

	def __add__(self,other):
		''' Adds blocks to a new inputDeck '''
		newDeck = _copy.deepcopy(self)
		newDeck += other

		return newDeck

	def __iadd__(self,other):
		''' Adds blocks to the inputDeck in place '''
		if isinstance(other,inputBlock):
			# Check block name is valid
			inputDeck._isValidBlockName(other.blockName,noerror=False)

			# Check whether block is already defined and does not allow multiple definitions
			if(inputDeck._getBlockDef(other.blockName)['allowMultiple'] == False and len(self._getBlocksOfType(other.blockName)) > 0):
				raise ValueError("Block \'"+other.blockName+"\' has already been defined and cannot be multiply defined.")

			# Check block for errors
			inputDeck.checkBlock(other,self.dims)

			# Create copy of block so can't be modified externally
			blockCopy = _copy.deepcopy(other)

			# Add it to the deck dictionary
			self._deck[other.blockName].append(blockCopy)
		elif isinstance(other,inputDeck):
			# Before adding check if new blocks are already present and do not allow for multiple definitions
			for block in other._getAllBlocks():
				if(inputDeck._getBlockDef(block.blockName)['allowMultiple'] == False and len(self._getBlocksOfType(block.blockName)) > 0):
					raise ValueError("Block \'"+block.blockName+"\' has already been defined and cannot be multiply defined.")

			# Now run through the blocks and add them
			for block in other._getAllBlocks():
				self += block
		return self

	def __sub__(self,other):
		''' Creates a new inputDeck without the specified blocks '''
		newDeck = _copy.deepcopy(self)
		newDeck -= other

		return newDeck

	def __isub__(self,other):
		''' Removes blocks from the inputDeck in place '''
		if isinstance(other,inputBlock):
			# First check whether the block is a member of our deck
			if other not in self:
				raise ValueError('No matching blocks found to remove')

			# Find blocks of same type
			blocks = self._getBlocksOfType(other.blockName)

			# Remove the offending block
			blocks.remove(other)
		elif isinstance(other,inputDeck):
			# Get list of blocks in other input deck
			blocks = other._getAllBlocks()

			# Before removing, check that all blocks to remove are present
			blocksPresent = [ block in self for block in blocks ]

			if not all(blocksPresent):
				raise ValueError("Not all blocks to remove are present")

			for block in blocks:
				self -= block
		return self

	@staticmethod
	def _getBlockNames():
		''' Returns a list of valid block names '''
		blockNames = inputDeck.blockDefinitions.keys()
		return blockNames

	@staticmethod
	def _isValidBlockName(bName,noerror=False):
		''' Checks whether a block name is valid '''
		isValid = bName in inputDeck._getBlockNames()

		if not noerror and not isValid:
			raise ValueError("\'{}\' is not a valid EPOCH input deck block name".format(bName))

		return isValid

	@staticmethod
	def _getBlockDef(blockName):
		''' Returns the definition of the named block '''
		blockDef = inputDeck.blockDefinitions[blockName]
		return blockDef

	@staticmethod
	def _getParameterDef(blockName,paramName):
		''' Returns the definition of a block's parameter '''
		block = inputDeck._getBlockDef(blockName)

		matchingParams = [ i for i in block['parameters'] if i['name'] == paramName ]

		if(len(matchingParams) == 1):
			return matchingParams[0]
		elif(len(matchingParams) == 0):
			return None
		else:
			raise RuntimeError('inputDeck.getParameter() matched multiple parameters.')

	@staticmethod
	def checkParameter(blockName,param,val,dims):
		''' Checks the value of a parameter against its definition '''
		pDef = inputDeck._getParameterDef(blockName,param)

		#for i,param in enumerate(blockParams):
		# Check type
		if isinstance(pDef['dType'],_collections.Container):
			allowed = None

			for t in pDef['dType']:
				try:
					t(val)
					allowed=True
				except TypeError:
					allowed = False
				except ValueError:
					allowed = False

			if(allowed == False):
				raise TypeError("Value of parameter \'"+param+"\' is of type "+type(val).__name__+", which is not compatible with one of "+str(tuple(pDef['dType'])))
		else:
			try:
				pDef['dType'](val)
			except TypeError:
				raise TypeError("Type of parameter \'"+param+"\' should be "+pDef['dType'].__name__+", not "+type(val).__name__)
			except ValueError:
				raise TypeError("Type of parameter \'"+param+"\' should be "+pDef['dType'].__name__+", not "+type(val).__name__)

		# If parameter requires an N-D EPOCH run, make sure we're set up for that
		if 'minD' in pDef:
			if dims < pDef['minD']:
				raise ValueError("Parameter \'"+param+"\' requires "+str(pDef['minD'])+"-D EPOCH, but using "+str(dims)+"-D")

		# If parameter has verification rules set up, test them
		if 'verification' in pDef:
			if not pDef['verification'](val):
				raise ValueError("Parameter \'"+param+"\' failed verification check")

		# If parameter has set of accepted values, check given value is allowed
		if 'allowedVals' in pDef:
			if val not in pDef['allowedVals']:
				raise ValueError("Parameter \'"+param+"\' given with value "+val+", but can only take the following values:\n"+str(pDef['allowedVals']))

	@staticmethod
	def checkBlock(block,dims):
		''' Check whether a given block's parameters satisfy the definition '''

		# Check parameters are individually specified correctly
		for p,val in block.items():
			if type(p) != str:
				raise TypeError("Parameter names must be strings")

			# Find parameter in definition list
			if not inputDeck._getParameterDef(block.blockName,p):
				raise ValueError("Parameter \'"+p+"\' is not a known parameter of block \'"+block.blockName+"\'")

			# Check value val of parameter p for errors
			inputDeck.checkParameter(block.blockName,p,val,dims)

		# Check whether all mandatory parameters are specified
		# First create list of mandatory names for given dimension (including
		# parameters which may allow for alternatives)
		mandatoryParams = [ p['name'] for p in inputDeck._getBlockDef(block.blockName)['parameters']
		                                  if p['mandatory']
										      and (p.get('minD') == None
											       or (p.get('minD') != None
											           and p.get('minD') <= dims)) ]

		# Find list of missing parameters, accounting for those which have alternatives given
		missingParams = []
		for m in mandatoryParams:
			if m not in block:
				if 'alternatives' in inputDeck._getParameterDef(block.blockName,m):
					alts = inputDeck._getParameterDef(block.blockName,m)['alternatives']
					if not any(True for i in alts if (i[0] == block.blockName and i[1] in block)
					                                  or i[0] != block.blockName):
						missingParams.append(m)
				else:
					missingParams.append(m)

		if len(missingParams) > 0:
			raise ValueError("The following mandatory parameters have not been specified:\n"+str(missingParams))

		# TODO: Check that all dependencies are satisfied

	def _getAllBlocks(self):
		''' Returns a list of all blocks in the deck

		Unlike the public version of the function it does not return a copy so
		modifying the contained data will modify the deck.
		'''
		allBlocks = []
		for bName,bList in self._deck.items():
			allBlocks.append(bList)

		return allBlocks

	def getAllBlocks(self):
		''' Returns a list of all blocks in the deck

		These blocks are copies of the internal data so do not modify it if
		themselves changed.
		'''
		return _copy.deepcopy(_getAllBlocks(self))

	def _getBlocksOfType(self,bName):
		''' Returns all blocks with a given name '''

		# Check the name is valid
		inputDeck._isValidBlockName(bName,noerror=False)

		return self._deck[bName]

	def getBlocksOfType(self,bName):
		''' Returns a copy of all blocks with a given name '''
		return _copy.deepcopy(self._getBlocksOfType(bName))


	# Perform all the checks we can't do while blocks are being added
	def isValid(self):
		return not self.whyInvalid()

	def whyInvalid(self):
		''' Gets a list of reasons why the deck is not valid

		Description
		-----------

		Looks for reasons why the deck is not valid and returns them as a list.
		If there are no reasons why the deck is invalid, returns None

		Tests performed:
		 - check that all mandatory blocks are present
		 - TODO: Check whether alternative parameters between blocks are specified
		 - TODO: Check parameter dependencies between blocks
		'''
		problemStringList = []

		missingBlocks = [ bName for bName in inputDeck._getBlockNames()
		                  if self._getBlocksOfType(bName) == []
		                  and inputDeck.blockDefinitions[bName]['mandatory'] ]

		if(len(missingBlocks) > 0):
			problemStringList.append("Missing blocks: " + str(missingBlocks))

		if(len(problemStringList) > 0): return problemStringList
		else: None

	def add(self,other):
		''' Alias of __iadd__ '''
		self += other

	def addBlock(self,block):
		''' Alias of __iadd__ but only for inputBlocks '''
		if not isinstance(block,inputBlock):
			raise TypeError('block should be an inputBlock')

		self += block

	def addDeck(self,deck):
		''' Alias of __iadd__ but only for inputDecks '''
		if not isinstance(block,inputDeck):
			raise TypeError('deck should be an inputDeck')

		self += deck

	def remove(self,other):
		''' Alias of __isub__ '''
		self -= other

	def removeBlock(self,block):
		''' Alias of __isub__ but only for blocks '''
		if not isinstance(block,inputBlock):
			raise TypeError('block should be an inputBlock')

		self -= block

	def removeDeck(self,deck):
		''' Alias of __isub__ but only for decks '''
		if not isinstance(block,inputDeck):
			raise TypeError('deck should be an inputDeck')

		self -= deck

	def removeBlocksOfType(self,blockName):
		''' Remove all blocks with a given name '''
		# Check whether block name is valid
		inputDeck._isValidBlockName(blockName,noerror=False)

		# Check whether such blocks exist
		if len(self._getBlocksOfType(blockName)) == 0:
			raise ValueError("No blocks with name \'"+blockName+"\'")

		# Remove the blocks
		self._deck[blockName] = []

	def writeToFile(self,fileName):
		if(type(fileName) != str):
			raise TypeError("fileName must be of type str, not "+type(fileName).__name__)
		if(_os.path.exists(fileName)):
			raise IOError('File '+fileName+' exists already')

		deck = self.__str__()
		with open(fileName,'w') as f: f.write(deck)

	def run(*args,**kwargs):
		run(*args,**kwargs)

def _startDaemon(target,*args,**kwargs):
	''' Hacky function to start a daemon from a Process '''
	_sys.__stdin__ = _os.fdopen(kwargs.pop('stdinfd'))
	with _daemon.DaemonContext(working_directory=_os.getcwd()):
		target(*args,**kwargs)

def _startService(target,*args,**kwargs):
	''' Starts a service using python-daemon and multiprocessing

	Slightly hacky, need to give child process the same stdin for some reason
	'''
	stdinfd = _sys.__stdin__.fileno()
	kwargs['stdinfd'] = stdinfd
	p = _mp.Process(target=_startDaemon,args=(target,)+args,kwargs=kwargs)
	p.start()

def run(deck,outputDir,executable=None,
        stdoutPrint=True,stderrPrint=True,
		stdoutLog=True,stderrLog=True,
        procs=_mp.cpu_count(),hpcResources=None,
        daemon=False):
	''' Function to manage running of an EPOCH input deck

	Desription
	----------

	This aims to handle running locally or through a resource manager
	transparently, i.e. it should behave the same way in either case.

	Input
	-----

	deck         : The input deck to give EPOCH, either as a file or an
	               inputDeck object.
	outputDir    : The directory in which to store output data, this must not
	               exist beforehand.
	executable   : Optional. The executable to use (e.g. if using different
	               EPOCH version)
	stdoutPrint, stderrPrint : Optional. True by default. Determine whether
	               stdout/stderr are printed to the terminal.
	stdoutLog, stderrLog : Optional. True by default. If True then
	               stdout/stderr are logged to a file. Alternatively,
	               a file name may be supplied as a string.
	procs        : Optional. If running locally then this controls the number
	               of processors launched by MPI. Set to the number of ores on
	               the machine by default.
	hpcResources : Optional. If running via a resource manager then this must
	               be supplied. Object of type resourceRequest (see pbsUtils).
	daemon       : Optional. False by default. If True then EPOCH will be run
	               by a separate daemon process. No output will be printed to
	               the terminal. Useful if running on a system over ssh where
	               the connection may be interrupted and the process otherwise
	               terminated.
	'''
	args = locals()

	# Figure out what we've been given in deck argument
	if isinstance(deck,inputDeck) or type(deck) == str:
		deckIsFile = not isinstance(deck,inputDeck)
	else:
		raise TypeError("deck should either be an inputDeck object or string")

	# Regardless of whether deck is a file or inputDeck object, make sure we have
	# the latter stored somewhere
	if deckIsFile:
		deckObj = readDeckFile(deck)
	else:
		deckObj = deck

	# Check input deck:
	if not deckObj.isValid():
		raise ValueError("Error: input deck failed validity check:\n{}".format('\n'.join(deckObj.whyInvalid())))

	# Check if our output directory exists, if so then throw error
	if _os.path.exists(outputDir):
		raise ValueError("Output directory exists already!")

	if stdoutLog == True: stdoutLog = _os.path.join(outputDir,'std.out')
	if stderrLog == True: stderrLog = _os.path.join(outputDir,'std.err')

	# FINISHED MAIN CHECKS
	# At this point we're happy that everything ought to be working, so if
	# we've been asked to run as a daemon then now's the time to fork. Do this
	# by running this function again with the daemon argument == False
	if daemon:
		daemonArgs = _copy.deepcopy(args)

		# Avoid continuously spawning daemons
		daemonArgs['daemon']       = False

		# No longer any need to print to stdout/stderr
		daemonArgs['stdoutPrint']  = False
		daemonArgs['stderrPrint']  = False

		# Set daemon process going
		_startService(run,**daemonArgs)

		# Return so we don't run EPOCH twice!
		return

	# Create output directory
	_os.mkdir(outputDir)

	# Write/copy input deck to output directory
	if not deckIsFile:
		deck.writeToFile(_os.path.join(outputDir,'input.deck'))
	else:
		_shutil.copy(deck,_os.path.join(outputDir,'input.deck'))

	if not executable:
		executable = 'epoch'+str(deckObj.dims)+'d'

	# Prepare to launch EPOCH via Popen
	# Either run it directly or in a resource manager via pbsUtils
	kwargs = {'stdout':_sp.PIPE,'stderr':_sp.PIPE,'bufsize':-1}
	if hpcResources:
		task = 'echo '+outputDir+' | srun '+executable

		# Convert hpcResources to command line arguments for pbsUtils
		pbsArgs = hpcResources.comArgs()

		# stdout/stderr logfiles are dealt with by pbsUtils, so tell it where
		# to write to and then pretend we're not logging
		if stdoutLog:
			pbsArgs += ['--output',stdoutLog]
			stdoutLog = None
		if stderrLog:
			pbsArgs += ['--error',stderrLog]
			stderrLog = None

		command = ['pbsUtils',task,'--watch','--pbsFile',_os.path.join(outputDir,'job.pbs')] + pbsArgs
	else:
		command = ['mpirun','-np',str(procs),executable]
		kwargs['stdin'] = _sp.PIPE

	# Launch EPOCH
	epoch = _sp.Popen(command,**kwargs)

	# Now that subprocess representing EPOCH has been launched, monitor its
	# output/error streams and log them if necessary
	outMon = outputMonitor(epoch,stdoutPrint,stderrPrint,stdoutLog,stderrLog)
	outMon.start()

	if not hpcResources:
		epoch.stdin.write((outputDir+'\n').encode())
		epoch.stdin.flush() # Ensure write doesn't sit in a buffer

	epoch.wait()
	outMon.stop()

class outputMonitor:
	''' Monitors the output of a running process in a Popen object '''
	def __init__(self,process,
	             printStdout,printStderr,
	             logStdout,logStderr):
		self.process     = process
		self.printStdout = printStdout
		self.printStderr = printStderr
		self.logStdout   = logStdout
		self.logStderr   = logStderr

		toutArgs = (self.process.stdout,self.printStdout,self.logStdout)
		terrArgs = (self.process.stderr,self.printStderr,self.logStderr)
		self.tout = _threading.Thread(target=self._handleOutput,args=toutArgs)
		self.terr = _threading.Thread(target=self._handleOutput,args=terrArgs)

	def start(self):
		# No point in starting threads if they are doing nothing
		if self.printStdout or self.logStdout:
			self.tout.start()
		if self.printStderr or self.logStderr:
			self.terr.start()

	def stop(self):
		if self.printStdout or self.logStdout:
			self.tout.join()
		if self.printStderr or self.logStderr:
			self.terr.join()

	@staticmethod
	def _handleOutput(fd,printOn,logFile):
		#print("handleOutput({fd},{printOn},{logFile})".format(fd=fd,printOn=printOn,logFile=logFile))
		if logFile: log = open(logFile,'w')
		with fd:
			for line in iter(fd.readline, b''):
				#line = fd.readline()
				#print('id: {ID} read line! len: {length}, closed: {closed}'.format(ID=id(fd),length=len(line),closed=fd.closed))
				if printOn: print(line,end='')
				if logFile:
					log.write(line.decode())
					log.flush()
				#_time.sleep(0.1)
		if logFile: log.close()


def estimateRequiredTime(dims,deck,outputDir,logFile=None,executable=None,
                         procs=_mp.cpu_count(),onHPC=False,
                         pbsFile=None,queue=None,nodes=None,procsPerNode=None,memPerProc=None,maxTime=5*60,
						 echo=False):
	''' Estimates the time required to run an input deck '''
	args = locals()
	# TODO: Modify input deck to output to stdout as frequently as possible
	# TODO: Get final time of simulation more reliably
	endTime = None
	if(isinstance(deck,inputDeck)):
		block = deck.getBlocks('control')
		#print(block)
		for param,val in block[0]['parameters']:
			if(param == 't_end'):
				endTime = val
		if(endTime == None):
			raise ValueError("Couldn't find t_end")

	elif(type(deck) == str):
		blocks = readDeckFile(deck)
		endTime = get_t_end(blocks)

	testArgs = _copy.deepcopy(args)
	testArgs['estimateTime'] = False
	testArgs['logFile']      = False # TODO: Are we sure we want to disable this?
	testArgs['daemon']       = False
	testArgs['wait']         = False
	testArgs['maxTime']      = maxTime+60 # Request 60 seconds more than we need to run our test

	if(onHPC):
		if(echo): print(_time.strftime('%d/%m/%y %H:%M:%S: ')+"Running EPOCH to estimate simulation runtime.")

		stdout,stderr,jobID = run(**testArgs)

		try:
			# Time from when the job starts running
			startTime = pbs.getStartTime(jobID)
			elapsed=0

			# Wait until job completes or exceeds maxTime
			if(echo):
				testEndTime = startTime + maxTime
				testEndTime = _dt.datetime.fromtimestamp(testEndTime)
				print(_time.strftime('%d/%m/%y %H:%M:%S: ')+"Waiting for EPOCH to complete or reach max. test time (at "+testEndTime.strftime('%H:%M:%S')+")")

			while(not pbs.isComplete(jobID) and elapsed < maxTime):
				_time.sleep(0.1)
				elapsed = _time.time()-startTime
		except KeyboardInterrupt:
			# If we get Ctrl-C before EPOCH finishes and we're waiting, try to
			# kill the job before exiting
			print('\n'+_time.strftime('%d/%m/%y %H:%M:%S: ')+"Caught Ctrl-C. Cancelling job.")
			pbs.killJob(jobID)
			assert pbs.isVacated(jobID), "Tried to kill job but it is still running"
			print(_time.strftime('%d/%m/%y %H:%M:%S: ')+"Successfully cancelled job.")

			exit()

		# Kill if job exceeds maxTime
		if(elapsed > maxTime):
			if(echo): print(_time.strftime('%d/%m/%y %H:%M:%S: ')+"EPOCH test run has reached max. test time, terminating...")
			pbs.killJob(jobID)
			assert pbs.isVacated(jobID), "Tried to kill job but it is still running"

		if(echo): print(_time.strftime('%d/%m/%y %H:%M:%S: ')+"EPOCH test run finished.")

		# Read stdout and stderr into list
		stdoutLines = stdout.readlines()
		stderrLines = []
		stderr = pbs.getOutput(jobID)[1]
		if(stderr != None):
			stderrLines = stderr.readlines()
	else:
		stdout,stderr,epoch = run(**testArgs)

		qout = _Queue.Queue()
		qerr = _Queue.Queue()
		tout = _threading.Thread(target=enqueue_output, args=(epoch.stdout, qout))
		terr = _threading.Thread(target=enqueue_output, args=(epoch.stderr, qerr))
		terr.daemon = tout.daemon = True # thread dies with the program
		tout.start()
		terr.start()

		# Check every 1.0 seconds whether epoch has finished
		stdoutLines = []
		stderrLines = []
		while(epoch.returncode == None):
			for q,strLst in [(qout,stdout),(qerr,stderr)]:
				while(q.empty() == False):
					line = qout.get()
					strLst.append(line)

			_time.sleep(1)
			epoch.poll()
			elapsed = _time.time()-startTime

			if(elapsed > maxTime):
					print("EPOCH hasn't finished after max time {:.2f}s, sending SIGTERM".format(maxTime))
					killProc(epoch,'EPOCH')

		for q,strLst in [(qout,stdoutLines),(qerr,stderrLines)]:
			while(q.empty() == False):
				line = qout.get()
				strLst.append(line)

		#print(stdoutLines)
		#print(stderrLines)

	stdoutSplit = [ line.strip().split() for line in stdoutLines if line.strip() != '' ]
	#print(stdoutSplit)
	simTimes  = [ float(line[1].strip(',')) for line in stdoutSplit if line[0] == 'Time' ]
	zeroTime = _time.mktime(_time.strptime('0:00:00:00','%w:%H:%M:%S'))
	realTimes = [ float(line[5].strip(',')[-3:])+_time.mktime(_time.strptime(line[5].strip(',')[:-3],'%w:%H:%M:%S'))-zeroTime for line in stdoutSplit if line[0] == 'Time' ]

	assert len(simTimes) == len(realTimes), "Error: number of simulation and elapsed times doesn\'t match"
	if(len(simTimes) <= 1): raise EnvironmentError("Error: insufficient timing data accumulated")
	#print(simTimes)
	#print(realTimes)

	outputDiffRatios = _np.diff(realTimes[1:])/_np.diff(simTimes[1:])
	meanDiffRatio = _np.mean(outputDiffRatios)
	stdDiffRatio = _np.std(outputDiffRatios)
	requiredTime = meanDiffRatio*(endTime-simTimes[0])
	requiredTimeErr = stdDiffRatio*(endTime-simTimes[0])

	print(requiredTime)
	print(requiredTimeErr)
	#requiredTime = (realTimes[-1] - realTimes[0])/(simTimes[-1] - simTimes[0])*(endTime - simTimes[0])

	if(echo): print(_time.strftime('%d/%m/%y %H:%M:%S: ')+"Estimated full simulation time as ~"+str(_dt.timedelta(seconds=requiredTime)))

	return requiredTime

#def optimiseNumNodes(dims,deck,outputDir,logFile=None,executable=None,
#                     pbsFile=None,queue=None,maxNodes=None,procsPerNode=None,memPerProc=None,maxTime=5*60,
#                     echo=False):
#	nodeNums = _np.logspace(0,_np.log(maxNodes,2)

def killProc(p,procName='process',graceTime = 5):
	# Send initial SIGTERM and start timing
	p.terminate()
	startTime = _time.time()
	elapsed = 0.0
	# Give process graceTime seconds to terminate
	while(p.returncode == None and elapsed < graceTime):
		_time.sleep(0.1)
		p.poll()
		elapsed = _time.time() - startTime

	# If process still hasn't terminated send SIGKILL
	if(p.returncode == None):
		print(procName+" *still* hasn't finished, despite SIGTERM signal, killing it")
		p.kill()

		# Wait for an extra graceTime seconds
		while(p.returncode == None and elapsed < 2*graceTime):
			_time.sleep(0.1)
			p.poll()
			elapsed = _time.time()-startTime

		# If process hasn't terminated now then throw error
		if(p.returncode == None):
			raise RuntimeError(procName+" just won't die...")

def readDeckFile(deckFile):
	''' Reads an input deck from a file into an inputDeck object '''
	with open(deckFile,'r') as deck:
		lines = [ i.strip() for i in deck.readlines() if i.strip() != '' and i.strip()[0] != '#' ]

	tempLines = []
	continues = False
	for l in lines:
		breakInd = l.find('\\')
		if breakInd != -1:
			line = l[:breakInd].strip()
		else:
			line = l

		if continues:
			tempLines[-1] += line
		else:
			tempLines.append(line)

		continues = (breakInd != -1)
	lines = tempLines
	#print(lines[:50])

	blocks = []
	inBlock = False
	for i in lines:
		if i[:6].lower() == 'begin:':
			if(inBlock): raise ValueError('Found start of new block inside an unfinished block')

			block = inputBlock(blockName = i[6:].lower())
			inBlock = True
		elif i[:4].lower() == 'end:':
			if(inBlock == False): raise ValueError('Found end of block without associated begin:')
			if(block.blockName != i[4:].lower()):
				raise ValueError('Block end name doesn\'t match begin: name')

			inBlock = False
			blocks.append(block)
		else:
			if not inBlock: raise ValueError('Not in block but found non-comment, non-empty line')

			assert i.count('=') != 0,"No equalities found in statement"
			assert i.count('=') == 1,"More than one equality in statement"
			eqIndex = i.find('=')

			key = i[:eqIndex].strip()
			val = i[eqIndex+1:].strip()

			if key in block:
				raise ValueError('Duplicate key {} found in input deck'.format(key))

			# Look up parameter definition
			paramDef = inputDeck._getParameterDef(block.blockName,key)

			if paramDef['dType'] == bool:
				if   val == 'T': block[key] = True
				elif val == 'F': block[key] = False
				else: raise ValueError('value of boolean parameter could not be identified: {}'.format(val))
			else:
				# parameter definitions may list multiple types, so try iterating
				# over them first. If this fails assume the object *is* a type
				try:
					for t in paramDef['dType']:
						try:
							block[key] = t(val)
							break
						except ValueError:
							continue
				except TypeError:
					block[key] = paramDef['dType'](val)
	if inBlock: raise ValueError('In block despite reaching EOF')

	for block in blocks:
		if block.blockName == 'control':
			if 'nz' in block:
				dims = 3
			elif 'ny' in block:
				dims = 2
			elif 'nx' in block:
				dims = 1
			else: raise ValueError("Control block doesn't have nx as a parameter!")

			break

	# Can't add blocks as they are read since we don't know the dimentionality
	deck = inputDeck(dims)
	for block in blocks:
		deck += block

	return deck

def calcDt(dx,dy=None,dz=None,
           op=None,vth=None,omega0=None,
		   field_order=2,dt_mult=0.95):
	'''
	Calculates the expected timestep for an EPOCH simulation

	Parameters
	----------

	d[x,y,z] : grid spacing in the x,y and z directions respectively
	op       : **Maximum** plasma frequency across the domain
	vth      : **Minimum** thermal velocity across the domain
	omega0   : Laser angular frequency
	field_order : Order of the EPOCH fields solver (default is 2)
	dt_mult  : dt multiplier, default is 0.95
	'''
	if (not dy) and dz:
		raise ValueError("3D simulation must have dy specified")

	if field_order == 2:
		cfl = 1.0
	elif field_order == 4:
		cfl = 6.0/7.0
	elif field_order == 6:
		cfl = 120.0/149.0
	else:
		raise ValueError("field_order must be 2, 4 or 6")

	if dz:
		dt = cfl*dx*dy*dz/_np.sqrt((dx*dy)**2 + (dy*dz)**2 + (dz*dx)**2)/_const.c
	elif dy:
		dt = cfl*dx*dy/_np.sqrt(dx**2 + dy**2)/_const.c
	else:
		dt = cfl*dx/_const.c

	if op and vth:
		dts = [ d for d in [dx,dy,dz] if d ]
		kMax = 2.0*_math.pi/min(dts)
		o = _np.sqrt(op**2 + 3.0*vth**2*kMax**2)
	elif op or vth:
		raise ValueError("To calculate plasma frequency need both ω_p and v_th")
	else:
		o = None

	if o: dt_plasma = 2.0*_math.pi/o
	else: dt_plasma = None

	if omega0: dt_laser = _math.pi/omega0 # Double laser frequency to resolve laser
	else     : dt_laser = None

	dts = [ d for d in [dt,dt_plasma,dt_laser] if d ]
	dt = dt_mult*min(dts)

	return dt
